---
title: 游戏性能优化(施工中)
tags:
  - GameDev
  - Performance
date: 2024-10-17
---

TODO:
* 游戏 + 动态追踪技术 => 模仿帧同步的log打点
* 关键指标（影响性能的核心数据）


### 游戏优化的特点

* 游戏优化讲究的是“在一帧的时间内，很快地完成1000件不同的事情”。游戏性能最直观的标准是帧率，每帧时间越短，帧率自然越高。但是帧率本身是分层的目标：30帧，60帧，120帧等等。举个例子，如果frame pacing没处理好的话，不稳定的40帧的给玩家带来的体验是不如稳定的30帧的。另外，玩家感受到的帧率也会被显示器的刷新率所限制，帧率超过刷新率的时候，显示器每秒所能显示的图像数量依然是不变的。
* 游戏本身的模块相当多，每个模块的逻辑都有区别，很难有一招鲜吃遍天的情况，更别提GPU相关的优化所需要的手段和CPU的就完全不同，都需要具体分析。
* 游戏项目一般时间紧迫，很多时候只能抓大放小，定位瓶颈然后制定计划优化。要考虑投入产出比，优化的风险（是否可热更）。优化是权衡的艺术，砍美术资源当然是最快的优化方案，但是会让美术、策划不高兴。



### 工具与准备

* 确定目标硬件和目标性能，硬件分档，制定每一档的性能目标。代码中尽早准备好相关的接口，可以做到按性能配置加载不同配置的资源、特效等。

* 尽可能早设立和使用每一档的美术标准，包括地图、模型、贴图、特效的制作规范等等，完善相应的资源静态与动态检查工具。

* 定时自动性能测试（自动跑图、Replay等），发现明显的性能regression自动报警。当然，也要注意工具本身带来的overhead。

  * 资源轮播、对比：在目标机型上加载所有的资源，可以记录加载资源的耗时、内存等；可以进行不同版本之间的比较，资源数量的控制。

  * 进阶：可以有自动化的归因，例如发现了FPS的regression，可以自动diff出耗时变长的模块；发现内存变多，可以自动抓快照对比出变多的内存条目等等。
  * 进阶：全自动化的性能对比机制，比如给一个包，指定某个机型，对比其打开关闭某个开关之后的性能，自动形成性能报告提供给开发来分析。

* GM开关，可以一键加载或关闭任意UI组件/地图区块/特效等，定位热点资源很有用；内网/本地热更机制 or 类似的加速迭代的机制，有利于修复性能问题时候的迭代速度。

* 静态代码分析工具，可以在提交代码前就报警：例如会造成GC的操作、在Update中打log等。



### 优化

#### 帧率

尤其对Unity这种太多逻辑绑在主线程的引擎而言，需要尽量不卡主线程：分帧，多线程（job），调整tick频率等等。

图形相关优化：控制drawcall，shader优化，overdraw优化，culling...



#### 内存

整体上，对于内存比较吃紧的机器来说是：

* 不用的就不加载，晚点用的就晚点加载（按需加载），能确定不用的就卸载。
* 需要加载的能不能降低质量：例如资源能不能做压缩（贴图压缩，animation、mesh能不能做16bit的压缩）、高低配等。
* 数据结构上的调整：例如容器数据结构能不能调优一下、扩容的参数能不能调整，如果有大量string能不能做前缀压缩等。

另一方面，32位机器除了内存占用本身以外，还要考虑虚拟内存的占用，优化这个需要一些来自安卓的专家帮忙，看下smaps的分布再进行针对性优化。



#### 卡顿

削峰填谷，非常业务向的优化

* 针对加载的卡顿：预加载、异步加载（按优先级分）、cache复用
* GC：高内存关gc，要GC的话则在感知不强的地方手动GC
* 分帧
* case by case：shader编译的卡顿则考虑prewarm，其他的具体问题具体分析



#### 启动时间

“能不做的就不做，一定要做的能不能少做、慢慢做、晚点做”

读取配置，异步/多线程 + 懒加载 + 二进制化，或者直接加进打包流程做进代码里。



#### 包体

压缩：zstd

分包，高清包

定期diff包体资源列表



### 渲染优化





### 超低端机优化

1G内存手机，定好目标：玩X局不crash。因此，内存需要优化到极限，即使以帧率和卡顿为代价。另外超低端机一般存储空间也极为有限，网速也不好，所以最小可玩包体要控制到很小。



### 总结

欢迎提issue交流：[Issues · jsjtxietian/jsjtxietian.github.io](https://github.com/jsjtxietian/jsjtxietian.github.io/issues)

